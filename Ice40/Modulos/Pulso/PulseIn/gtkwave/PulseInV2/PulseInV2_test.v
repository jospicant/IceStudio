// Code generated by Icestudio 0.3.3
// Mon, 03 Dec 2018 00:31:49 GMT

`default_nettype none

module main (
 input vd748c5,
 input v80c520,
 input vc31cf8,
 output [15:0] v0755f8,
 output [15:0] vfb470d,
 output v25a280,
 output [0:4] vinit
);
 wire [0:15] w0;
 wire [0:15] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire [0:15] w14;
 assign vfb470d = w1;
 assign w2 = vd748c5;
 assign w4 = vd748c5;
 assign v25a280 = w5;
 assign w6 = vd748c5;
 assign w7 = v80c520;
 assign w9 = v80c520;
 assign w11 = v80c520;
 assign w12 = vc31cf8;
 assign w13 = vc31cf8;
 assign v0755f8 = w14;
 assign w4 = w2;
 assign w5 = w3;
 assign w6 = w2;
 assign w6 = w4;
 assign w9 = w7;
 assign w10 = w3;
 assign w10 = w5;
 assign w11 = w7;
 assign w11 = w9;
 assign w13 = w12;
 assign w14 = w0;
 v528969 v97e3b5 (
  .vcbab45(w8),
  .v0e28cb(w9),
  .v3ca442(w10)
 );
 v8243c9 v4e5ed4 (
  .v26b754(w0),
  .vdd729a(w6),
  .ve61673(w8),
  .v7c533e(w13)
 );
 vcda464 v2184ee (
  .v11536b(w0),
  .v01aa16(w1),
  .v97b64a(w2),
  .vc3ff44(w3),
  .v9d2436(w11)
 );
 v69d0bb vd54a50 (
  .v317e8f(w3),
  .v02d455(w4),
  .v4ae82c(w7),
  .v08bfd6(w12)
 );
 assign vinit = 5'b00000;
endmodule

module v528969 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v528969_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module v528969_vf4938a (
 input a,
 input b,
 output c
);
 // OR logic gate
 
 assign c = a | b;
endmodule

module v8243c9 (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [15:0] v26b754
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:15] w3;
 assign w0 = ve61673;
 assign w1 = vdd729a;
 assign w2 = v7c533e;
 assign v26b754 = w3;
 v8243c9_vbd6086 vbd6086 (
  .rst(w0),
  .clk(w1),
  .en(w2),
  .q(w3)
 );
endmodule

module v8243c9_vbd6086 (
 input clk,
 input rst,
 input en,
 output [15:0] q
);
 //-- Numero de bits del contador
 localparam N = 16;      // 16 bits
 localparam M = 2**N-1;  // 2^16 -1 = 65535
                         // cuenta de 0 a 65535
 reg [N-1:0] qi = 0;
 
 always @(posedge clk)
   if (rst)
     qi <= 0;
   else if (en)
       qi <= qi + 1; //Suma cuando esté 
                     //habilitado
   else qi<=qi;
   
 assign q = qi;
 
 
     
endmodule

module vcda464 (
 input [15:0] v11536b,
 input vc3ff44,
 input v9d2436,
 input v97b64a,
 output [15:0] v01aa16
);
 wire [0:15] w0;
 wire [0:15] w1;
 wire w2;
 wire w3;
 wire w4;
 assign v01aa16 = w0;
 assign w1 = v11536b;
 assign w2 = v9d2436;
 assign w3 = vc3ff44;
 assign w4 = v97b64a;
 vcda464_v67385c v67385c (
  .q(w0),
  .d(w1),
  .reset(w2),
  .load(w3),
  .clk(w4)
 );
endmodule

module vcda464_v67385c (
 input [15:0] d,
 input load,
 input reset,
 input clk,
 output [15:0] q
);
 
 reg[15:0] qi=0;
 
 always @(posedge clk or posedge reset)
 if(reset)
  qi<=0;
 else if(load)
   qi<=d;
 else
  qi<=qi;
  
 assign q=qi;
 
 
 
endmodule

module v69d0bb (
 input v02d455,
 input v4ae82c,
 input v08bfd6,
 output v317e8f
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign v317e8f = w0;
 assign w1 = v4ae82c;
 assign w2 = v02d455;
 assign w3 = v08bfd6;
 v69d0bb_v3523b6 v3523b6 (
  .Falling(w0),
  .reset(w1),
  .clk(w2),
  .in(w3)
 );
endmodule

module v69d0bb_v3523b6 (
 input clk,
 input reset,
 input in,
 output Falling
);
 
 reg Q1=0,Q2=0;
 
 //Biestable D donde capturo estado actual (in) y anterior (Q)
 always @(posedge clk)
 if(reset)
    begin
       Q1<=1'b0;
       Q2<=1'b0;
    end 
 else
    begin       //Dos biestables encadenados
      Q1<=in;
      Q2<=Q1;
    end 
 
 //Con datos del estado actual ya anterior, realizando un circutio combinacional
 //puedo saber si la señal ha cambiado y si ha subido o ha bajado el flanco.
 
 assign Falling = (~in & Q2)& ~reset ; // Si in (Actual) es 0 pero antes (Q) era 1 -->Falling
 
endmodule
