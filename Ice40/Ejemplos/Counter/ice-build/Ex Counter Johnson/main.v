// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main #(
 parameter v9a42ce = 1,
 parameter v2c7621 = 5
) (
 input vb21a72,
 output [7:0] ve656cb
);
 localparam p0 = v9a42ce;
 localparam p3 = v2c7621;
 wire w1;
 wire [0:7] w2;
 wire w4;
 wire w5;
 assign w1 = vb21a72;
 assign ve656cb = w2;
 v1ea708 #(
  .v40705a(p0)
 ) vd5b7d4 (
  .v225a48(w1),
  .v5a14f0(w4)
 );
 v07a2b6 #(
  .v096fc3(p3)
 ) v51d1c2 (
  .v592a03(w2),
  .vdfc389(w4),
  .v6d4059(w5)
 );
 vb734f6 vf55d6c (
  .v9fb85f(w5)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module v1ea708 #(
 parameter v40705a = 0
) (
 input v225a48,
 output v5a14f0
);
 localparam p0 = v40705a;
 wire w1;
 wire w2;
 assign v5a14f0 = w1;
 assign w2 = v225a48;
 v1ea708_v2d11c0 #(
  .T_sg(p0)
 ) v2d11c0 (
  .clk(w1),
  .i_clock(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- clock   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Configurable signal clock
/*-------------------------------------------------*/

module v1ea708_v2d11c0 #(
 parameter T_sg = 0
) (
 input i_clock,
 output clk
);
 
   // Constants (parameters) to create the frequencies needed:
   // Input clock is 12MHz, chosen arbitrarily.
   // Formula is: (12MHz / f_target * 50% duty cycle)
   // So for 100 Hz: 12000000 / 100 * 0.5 = 60000
   
   localparam i_freq=12000000; //internal frequency FPGA IceStick
   localparam cuenta_Hasta = i_freq*T_sg/2;
   localparam N=$clog2(cuenta_Hasta);
   
   // These signals will be the counters:
   reg [N-1:0] contador=0;
   
   // These signals will toggle at the frequencies needed:
   reg T = 0;
  
   always @ (posedge i_clock)
    contador <= (contador == cuenta_Hasta-1) ? 0 : contador + 1;
 
   always @(posedge i_clock)
   begin
    if (contador==0)
      T<=!T;
    else
      T=T;
   end
   
   assign clk=T;
   
   
   
     
endmodule
//---- Top entity
module v07a2b6 #(
 parameter v096fc3 = 3
) (
 input vdfc389,
 input v6d4059,
 output [7:0] v592a03
);
 localparam p0 = v096fc3;
 wire [0:7] w1;
 wire w2;
 wire w3;
 assign v592a03 = w1;
 assign w2 = vdfc389;
 assign w3 = v6d4059;
 v07a2b6_v7153d7 #(
  .Nbits(p0)
 ) v7153d7 (
  .Q(w1),
  .ClockJ(w2),
  .PreClear(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Johnson Counter  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Johnson Counter
/*-------------------------------------------------*/

module v07a2b6_v7153d7 #(
 parameter Nbits = 0
) (
 input ClockJ,
 input PreClear,
 output [7:0] Q
);
 
 
 reg[7:0] Q=0;
 
 always @(negedge PreClear or negedge ClockJ)
 if(!PreClear)
 Q<=0;
 else
 //Mientras el bit m치s significativos sea 0
 //se cogen de Nbits-2:0 y se a침ade un 1 por la
 //derecha.
 //Una vez se encuentra un 1 en el bit m치s
 //significativo se empezar치n a introducir 0's
 //por la derecha
 begin
   if(!Q[Nbits-1])
    Q<={Q[Nbits-2:0],1'b1};
   else
    Q<={Q[Nbits-2:0],1'b0};
 end
 
 
endmodule
//---- Top entity
module vb734f6 (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 vb734f6_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 1
/*-------------------------------------------------*/

module vb734f6_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
