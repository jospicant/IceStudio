// Code generated by Icestudio 0.3.0-rc
// Sun, 09 Jul 2017 21:48:23 GMT

`default_nettype none

module main #(
 parameter v378406 = 4
) (
 input vclk,
 output [1:8] va204b6
);
 localparam p3 = v378406;
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w4;
 wire w5;
 wire w6;
 wire w7;
 assign va204b6 = w4;
 assign w7 = vclk;
 v7c0ae7 va2f66f (
  .v2efea4(w1),
  .v0daa9e(w7)
 );
 vfec7ff vbcd2fb (
  .v9fb85f(w5)
 );
 v100245 vf44df2 (
  .v6cebb8(w0),
  .vf45266(w1)
 );
 v100245 vc87fd8 (
  .vf45266(w0),
  .v6cebb8(w2)
 );
 v100245 v19ec03 (
  .vf45266(w2),
  .v6cebb8(w6)
 );
 v0033ac #(
  .v96f497(p3)
 ) vb793e8 (
  .vf6c629(w4),
  .veebb5a(w5),
  .vae3357(w6)
 );
endmodule

module v7c0ae7 (
 input v0daa9e,
 output v2efea4
);
 wire w0;
 wire w1;
 assign v2efea4 = w0;
 assign w1 = v0daa9e;
 v7c0ae7_v0bf905 v0bf905 (
  .clk_1hz(w0),
  .clk(w1)
 );
endmodule

module v7c0ae7_v0bf905 (
 input clk,
 output clk_1hz
);
 //-- module bomba_x1(input wire clk, output wire clk_1hz)
 
 //-- Bombeo de bits a 1Hz (1 pulsacion por segundo)
 
 //-- Constante para dividir y obtener una frecuencia de 2Hz
 localparam M = 6000000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Contador modulo M. tras M pulsos de relog vuelve a 0
 always @(posedge clk)
   divcounter <= (divcounter == M - 1) ? 0 : divcounter + 1;
 
 //-- Obtener la señal de 2Hz. La señal no tiene ciclo del 50%
 wire clk_2hz;
 assign clk_2hz = divcounter[N-1]; 
 
 //-- Usamos un biestable T para dividir entre 2 y obtener una señal
 //-- de 1Hz y ciclo del 50%
 reg T = 0;
 always @(posedge clk_2hz)
   T <= ~T;
   
 //-- Señal de salida de 1Hz y ciclo del 50%
 assign clk_1hz = T;
   
 //endmodule
  
 
 
endmodule

module vfec7ff (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 vfec7ff_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

module vfec7ff_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule

module v100245 (
 input vf45266,
 output v6cebb8
);
 wire w0;
 wire w1;
 assign w0 = vf45266;
 assign v6cebb8 = w1;
 v100245_v83141e v83141e (
  .T(w0),
  .q(w1)
 );
endmodule

module v100245_v83141e (
 input T,
 output q
);
 reg _q = 0;
 
 always @(posedge T)
   _q <= ~_q;
   
 assign q = _q;
 
endmodule

module v0033ac #(
 parameter v96f497 = 8
) (
 input veebb5a,
 input vae3357,
 output [1:8] vf6c629,
 output [1:8] vc629f2
);
 localparam p0 = v96f497;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire [0:7] w4;
 assign w1 = veebb5a;
 assign w2 = vae3357;
 assign vf6c629 = w3;
 assign vc629f2 = w4;
 v0033ac_v510edc #(
  .Nbits(p0)
 ) v510edc (
  .Clear(w1),
  .clk(w2),
  .Q(w3),
  .Qn(w4)
 );
endmodule

module v0033ac_v510edc #(
 parameter Nbits = 0
) (
 input Clear,
 input clk,
 output [1:8] Q,
 output [1:8] Qn
);
 
 localparam n=Nbits;
 
 reg [1:n] Counter,GrayCount; //Counter=contador normal
                                    //GrayCount = Contador de Gray
 integer k;
 
 always @(posedge clk)        //Contador normal
   if (Clear)
     Counter<=0;
   else
     Counter<=Counter+1;
 
 //Se realiza una operación xor del 2º bit con el 1º, del 3º con
 //el 2º, del 4º con el 3º y así sucesivamente....
 //por lo cual se realiza la operación xor entre cada par de bits
 //adyacentes.
 
 always @(Counter)            //Contador de Gray
 begin
 
     GrayCount[1]=Counter[1];
 
     for (k=2;k<=n;k=k+1) 
       GrayCount[k]=Counter[k-1] ^ Counter[k];
 end
 
 assign Q=GrayCount;
 assign Qn=~GrayCount;
 
 
 
endmodule
